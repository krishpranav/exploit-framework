package context

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/krishpranav/exploit-framework/lib/util/compiler"
	"github.com/krishpranav/exploit-framework/lib/util/hash"
	"github.com/krishpranav/exploit-framework/lib/util/log"
	oss "github.com/krishpranav/exploit-framework/lib/util/os"
	"github.com/krishpranav/exploit-framework/lib/util/str"
	humanize "github.com/dustin/go-humanize"
	"github.com/jedib0t/go-pretty/table"
	"github.com/vbauerster/mpb/v6"
	"github.com/vbauerster/mpb/v6/decor"
	"golang.org/x/term"
)

type TCPClient struct {
	conn              net.Conn
	interactive       bool
	ptyEstablished    bool
	GroupDispatch     bool                `json:"group_dispatch"`
	Hash              string              `json:"hash"`
	Host              string              `json:"host"`
	Port              uint16              `json:"port"`
	Alias             string              `json:"alias"`
	User              string              `json:"user"`
	OS                oss.OperatingSystem `json:"os"`
	NetworkInterfaces map[string]string   `json:"network_interfaces"`
	Python2           string              `json:"python2"`
	Python3           string              `json:"python3"`
	TimeStamp         time.Time           `json:"timestamp"`
	echoEnabled       bool
	server            *TCPServer
	readLock          *sync.Mutex
	writeLock         *sync.Mutex
	interacting       *sync.Mutex
	mature            bool
}

func CreateTCPClient(conn net.Conn, server *TCPServer) *TCPClient {
	host := strings.Split(conn.RemoteAddr().String(), ":")[0]
	port, _ := strconv.Atoi(strings.Split(conn.RemoteAddr().String(), ":")[1])
	return &TCPClient{
		TimeStamp:         time.Now(),
		echoEnabled:       false,
		server:            server,
		conn:              conn,
		interactive:       false,
		ptyEstablished:    false,
		GroupDispatch:     false,
		Hash:              "",
		Host:              host,
		Port:              uint16(port),
		Alias:             "",
		NetworkInterfaces: map[string]string{},
		OS:                oss.Unknown,
		Python2:           "",
		Python3:           "",
		User:              "",
		readLock:          new(sync.Mutex),
		writeLock:         new(sync.Mutex),
		interacting:       new(sync.Mutex),
		mature:            false,
	}
}

func (c *TCPClient) Close() {
	log.Debug("Closing client: %s", c.FullDesc())
	c.conn.Close()
}

func (c *TCPClient) GetConnString() string {
	return c.conn.RemoteAddr().String()
}

func (c *TCPClient) GetHashFormat() string {
	return c.server.hashFormat
}

func (c *TCPClient) GetConn() net.Conn {
	return c.conn
}

func (c *TCPClient) GetInteractingLock() *sync.Mutex {
	return c.interacting
}

func (c *TCPClient) GetInteractive() bool {
	return c.interactive
}

func (c *TCPClient) SetInteractive(new bool) bool {
	old := c.interactive
	c.interactive = new
	return old
}

func (c *TCPClient) GetPtyEstablished() bool {
	return c.ptyEstablished
}

func (c *TCPClient) SetPtyEstablished(new bool) bool {
	old := c.ptyEstablished
	c.ptyEstablished = new
	return old
}

func (c *TCPClient) GetUsername() string {
	var username string
	if c.User == "" {
		username = "unknown"
	} else {
		username = c.User
	}
	return username
}

func (c *TCPClient) GetPrompt() string {
	if c.Alias != "" {
		return fmt.Sprintf(
			"[%s] (%s) %s [%s] » ",
			c.Alias,
			c.OS.String(),
			c.GetConnString(),
			c.GetUsername(),
		)
	}
	return fmt.Sprintf(
		"(%s) %s [%s] » ",
		c.OS.String(),
		c.GetConnString(),
		c.GetUsername(),
	)
}

func (c *TCPClient) AsTable() {
	t := table.NewWriter()
	t.SetOutputMirror(os.Stdout)
	t.AppendHeader(table.Row{"Hash", "Network", "OS", "User", "Python", "Time", "Alias", "GroupDispatch"})
	t.AppendRow([]interface{}{
		c.Hash,
		c.conn.RemoteAddr().String(),
		c.OS.String(),
		c.User,
		c.Python2 != "" || c.Python3 != "",
		humanize.Time(c.TimeStamp),
		c.Alias,
		c.GroupDispatch,
	})
	t.Render()
}

func (c *TCPClient) makeHash(hashFormat string) string {
	data := ""
	if c.OS == oss.Linux {
		components := strings.Split(hashFormat, " ")
		mapping := map[string]string{
			"%i": strings.Split(c.conn.RemoteAddr().String(), ":")[0],
			"%u": c.User,
			"%o": c.OS.String(),
			"%m": fmt.Sprintf("%s", c.NetworkInterfaces),
			"%t": c.TimeStamp.String(),
		}
		for _, component := range components {
			if value, exists := mapping[component]; exists {
				data += value
				data += "\n"
			} else {
				data += component
			}
		}
	} else {
		data = c.conn.RemoteAddr().String()
	}
	log.Debug("Hashing: %s", data)
	return hash.MD5(data)
}

func (c *TCPClient) OnlineDesc() string {
	addr := c.conn.RemoteAddr()
	if c.mature {
		return fmt.Sprintf("[%s] %s://%s [%s]", c.Hash, addr.Network(), addr.String(), c.OS.String())
	} else {
		return fmt.Sprintf("[Premature Death] %s://%s [%s]", addr.Network(), addr.String(), c.OS.String())
	}
}

func (c *TCPClient) FullDesc() string {
	addr := c.conn.RemoteAddr()
	if c.mature {
		return fmt.Sprintf("[%s] %s://%s (connected at: %s) [%s] [%t]", c.Hash, addr.Network(), addr.String(),
			humanize.Time(c.TimeStamp), c.OS.String(), c.GroupDispatch)
	} else {
		return fmt.Sprintf("[Premature Death] %s://%s (connected at: %s) [%s] [%t]", addr.Network(), addr.String(),
			humanize.Time(c.TimeStamp), c.OS.String(), c.GroupDispatch)
	}
}

func (c *TCPClient) ReadUntilClean(token string) string {
	inputBuffer := make([]byte, 1)
	var outputBuffer bytes.Buffer
	for {
		c.conn.SetReadDeadline(time.Now().Add(time.Second * 1))
		n, err := c.ReadConnLock(inputBuffer)

		if err != nil {
			if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
				log.Error("Read response timeout from client")
			} else {
				log.Error("Read from client failed")
				c.interactive = false
				Ctx.Current = nil
				Ctx.DeleteTCPClient(c)
				return outputBuffer.String()
			}
			break
		}

		outputBuffer.Write(inputBuffer[:n])
		// If found token, then finish reading
		if strings.HasSuffix(outputBuffer.String(), token) {
			break
		}
	}
	c.conn.SetReadDeadline(time.Time{})
	// log.Debug("%d bytes read from client", len(outputBuffer.String()))
	return outputBuffer.String()[:len(outputBuffer.String())-len(token)]
}

func (c *TCPClient) ReadUntil(token string) (string, bool) {
	inputBuffer := make([]byte, 1)
	var outputBuffer bytes.Buffer
	var isTimeout bool
	for {
		c.conn.SetReadDeadline(time.Now().Add(time.Second * 1))
		n, err := c.ReadConnLock(inputBuffer)
		if err != nil {
			if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
				log.Error("Read response timeout from client")
				isTimeout = true
			} else {
				log.Error("Read from client failed")
				c.interactive = false
				Ctx.Current = nil
				Ctx.DeleteTCPClient(c)
				isTimeout = false
			}
			break
		}
		outputBuffer.Write(inputBuffer[:n])
		// If found token, then finish reading
		if strings.HasSuffix(outputBuffer.String(), token) {
			break
		}
	}
	c.conn.SetReadDeadline(time.Time{})
	// log.Info("%d bytes read from client", len(outputBuffer.String()))
	return outputBuffer.String(), isTimeout
}
