package context

import (
	"encoding/gob"
	"github.com/WangYihang/Platypus/lib/util/log"
	"github.com/WangYihang/Platypus/lib/util/message"
	"net"
	"strconv"
	"strings"
	"sync"
	"time"

	"gopkg.in/olahol/melody.v1"

	oss "github.com/krishpranav/exploit-framework/lib/util/os"
)

type ProcessState int

const (
	StartRequested ProcessState = iota
	Started
	TerminatRequested
	Terminated
)

type Process struct {
	Pid           int
	WindowColumns int
	WindowRows    int
	State         ProcessState
	WebSocket     *melody.Session
}

type TermiteClient struct {
	conn              net.Conn
	Hash              string              `json:"hash"`
	Host              string              `json:"host"`
	Port              uint16              `json:"port"`
	Alias             string              `json:"alias"`
	User              string              `json:"user"`
	OS                oss.OperatingSystem `json:"os"`
	NetworkInterfaces map[string]string   `json:"network_interfaces"`
	Python2           string              `json:"python2"`
	Python3           string              `json:"python3"`
	TimeStamp         time.Time           `json:"timestamp"`
	server            *TCPServer
	EncoderLock       *sync.Mutex
	DecoderLock       *sync.Mutex
	AtomLock          *sync.Mutex
	Encoder           *gob.Encoder
	Decoder           *gob.Decoder
	Processes         map[string]*Process
	CurrentProcessKey string
}

func CreateTermiteClient(conn net.Conn, server *TCPServer) *TermiteClient {
	host := strings.Split(conn.RemoteAddr().String(), ":")[0]
	port, _ := strconv.Atoi(strings.Split(conn.RemoteAddr().String(), ":")[1])
	return &TermiteClient{
		conn:              conn,
		Hash:              "",
		Host:              host,
		Port:              uint16(port),
		Alias:             "",
		User:              "",
		OS:                oss.Unknown,
		NetworkInterfaces: map[string]string{},
		Python2:           "",
		Python3:           "",
		TimeStamp:         time.Now(),
		server:            server,
		EncoderLock:       new(sync.Mutex),
		DecoderLock:       new(sync.Mutex),
		AtomLock:          new(sync.Mutex),
		Encoder:           gob.NewEncoder(conn),
		Decoder:           gob.NewDecoder(conn),
		Processes:         map[string]*Process{},
		CurrentProcessKey: "",
	}
}

func (c *TermiteClient) GetHashFormat() string {
	return c.server.hashFormat
}

func (c *TermiteClient) GatherClientInfo(hashFormat string) bool {
	log.Info("Gathering information from termite client...")

	c.AtomLock.Lock()
	defer func() { c.AtomLock.Unlock() }()

	// Send gather info request
	c.EncoderLock.Lock()
	err := c.Encoder.Encode(message.Message{
		Type: message.GET_CLIENT_INFO,
		Body: message.BodyGetClientInfo{},
	})
	c.EncoderLock.Unlock()

	if err != nil {
		// Network
		log.Error("Network error: %s", err)
		return false
	}

	// Read client response
	msg := &message.Message{}
	c.DecoderLock.Lock()
	err = c.Decoder.Decode(msg)
	c.DecoderLock.Unlock()

	if err != nil {
		log.Error("%s", err)
		return false
	}

	if msg.Type == message.CLIENT_INFO {
		clientInfo := msg.Body.(*message.BodyClientInfo)
		c.OS = oss.Parse(clientInfo.OS)
		c.User = clientInfo.User
		c.Python2 = clientInfo.Python2
		c.Python3 = clientInfo.Python3
		c.NetworkInterfaces = clientInfo.NetworkInterfaces
		c.Hash = c.makeHash(hashFormat)
		return true
	} else {
		log.Error("Client sent unexpected message type: %v", msg)
		return false
	}
}


func (c *TermiteClient) NotifyPlatypusWindowSize(columns int, rows int) {
	c.AtomLock.Lock()
	defer func() { c.AtomLock.Unlock() }()

	if _, exists := c.Processes[c.CurrentProcessKey]; exists {
		c.EncoderLock.Lock()
		err := c.Encoder.Encode(message.Message{
			Type: message.WINDOW_SIZE,
			Body: message.BodyWindowSize{
				Key:     c.CurrentProcessKey,
				Columns: columns,
				Rows:    rows,
			},
		})
		c.EncoderLock.Unlock()

		if err != nil {
			// Network
			log.Error("Network error: %s", err)
			Ctx.DeleteTermiteClient(c)
			return
		}
	} else {
		log.Error("No such process")
	}
}


func (c *TermiteClient) NotifyExploitFrameworkWindowSize(columns int, rows int) {
	c.AtomLock.Lock()
	defer func() { c.AtomLock.Unlock() }()

	if _, exists := c.Processes[c.CurrentProcessKey]; exists {
		c.EncoderLock.Lock()
		err := c.Encoder.Encode(message.Message{
			Type: message.WINDOW_SIZE,
			Body: message.BodyWindowSize{
				Key:     c.CurrentProcessKey,
				Columns: columns,
				Rows:    rows,
			},
		})
		c.EncoderLock.Unlock()

		if err != nil {
			// Network
			log.Error("Network error: %s", err)
			Ctx.DeleteTermiteClient(c)
			return
		}
	} else {
		log.Error("No such process")
	}
}