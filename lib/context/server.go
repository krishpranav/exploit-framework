package context

import (
	"bytes"
	"crypto/rand"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"net"
	"os"
	"strings"
	"time"


	"github.com/krishpranav/exploit-framework/lib/util/crypto"
	"github.com/krishpranav/exploit-framework/lib/util/hash"
	"github.com/krishpranav/exploit-framework/lib/util/log"
	"github.com/krishpranav/exploit-framework/lib/util/message"
	"github.com/krishpranav/exploit-framework/lib/util/network"
	"github.com/krishpranav/exploit-framework/lib/util/raas"
	"github.com/krishpranav/exploit-framework/lib/util/str"

	humanize "github.com/dustin/go-humanize"
	"github.com/jedib0t/go-pretty/table"
)

type WebSocketMessage struct {
	Type WebSocketMessageType
	Data interface{}
}

type TCPServer struct {
	Host           string                      `json:"host"`
	GroupDispatch  bool                        `json:"group_dispatch"`
	Port           uint16                      `json:"port"`
	Clients        map[string](*TCPClient)     `json:"clients"`
	TermiteClients map[string](*TermiteClient) `json:"termite_clients"`
	TimeStamp      time.Time                   `json:"timestamp"`
	Interfaces     []string                    `json:"interfaces"`
	Hash           string                      `json:"hash"`
	Encrypted      bool                        `json:"encrypted"`
	hashFormat     string
	stopped        chan struct{}
}

func CreateTCPServer(host string, port uint16, hashFormat string, encrypted bool) *TCPServer {
	service := fmt.Sprintf("%s:%d", host, port)

	if Ctx.Servers[hash.MD5(service)] != nil {
		log.Error("The server (%s) already exists", service)
		return nil
	}

	// Default hashFormat
	if hashFormat == "" {
		hashFormat = "%i %u %m %o %t"
	}

	tcpServer := &TCPServer{
		Host:           host,
		Port:           port,
		GroupDispatch:  true,
		Clients:        make(map[string](*TCPClient)),
		TermiteClients: make(map[string](*TermiteClient)),
		Interfaces:     []string{},
		TimeStamp:      time.Now(),
		hashFormat:     hashFormat,
		Hash:           hash.MD5(fmt.Sprintf("%s:%d", host, port)),
		stopped:        make(chan struct{}, 1),
		Encrypted:      encrypted,
	}

	Ctx.Servers[hash.MD5(service)] = tcpServer

	// Gather listening interfaces
	tcpServer.Interfaces = network.GatherInterfacesList(tcpServer.Host)

	// Support for distributor for termite
	if encrypted {
		for _, ifaddr := range tcpServer.Interfaces {
			routeKey := str.RandomString(0x08)
			Ctx.Distributor.Route[fmt.Sprintf("%s:%d", ifaddr, port)] = routeKey
		}
	}

	// Try to check
	log.Info("Trying to create server on: %s", service)
	tcpAddr, err := net.ResolveTCPAddr("tcp4", service)
	if err != nil {
		log.Error("Resolve TCP address failed: %s", err)
		Ctx.DeleteServer(tcpServer)
		return nil
	}

	listener, err := net.ListenTCP("tcp", tcpAddr)
	if err != nil {
		log.Error("Listen failed: %s", err)
		Ctx.DeleteServer(tcpServer)
		return nil
	} else {
		listener.Close()
	}

	return tcpServer
}